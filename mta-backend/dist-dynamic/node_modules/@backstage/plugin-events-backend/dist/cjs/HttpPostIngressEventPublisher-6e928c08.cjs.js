'use strict';

var backendCommon = require('@backstage/backend-common');
var express = require('express');
var Router = require('express-promise-router');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var express__default = /*#__PURE__*/_interopDefaultLegacy(express);
var Router__default = /*#__PURE__*/_interopDefaultLegacy(Router);

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class DefaultEventBroker {
  constructor(logger) {
    this.logger = logger;
    __publicField$1(this, "subscribers", {});
  }
  async publish(params) {
    var _a;
    this.logger.debug(
      `Event received: topic=${params.topic}, metadata=${JSON.stringify(
        params.metadata
      )}, payload=${JSON.stringify(params.eventPayload)}`
    );
    const subscribed = (_a = this.subscribers[params.topic]) != null ? _a : [];
    await Promise.all(
      subscribed.map(async (subscriber) => {
        try {
          await subscriber.onEvent(params);
        } catch (error) {
          this.logger.error(
            `Subscriber "${subscriber.constructor.name}" failed to process event`,
            error
          );
        }
      })
    );
  }
  subscribe(...subscribers) {
    subscribers.flat().forEach((subscriber) => {
      subscriber.supportsEventTopics().forEach((topic) => {
        var _a;
        this.subscribers[topic] = (_a = this.subscribers[topic]) != null ? _a : [];
        this.subscribers[topic].push(subscriber);
      });
    });
  }
}

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _rejectionDetails;
class RequestValidationContextImpl {
  constructor() {
    __privateAdd(this, _rejectionDetails, void 0);
  }
  reject(details) {
    var _a, _b;
    __privateSet(this, _rejectionDetails, {
      status: (_a = details == null ? void 0 : details.status) != null ? _a : 403,
      payload: (_b = details == null ? void 0 : details.payload) != null ? _b : {}
    });
  }
  wasRejected() {
    return __privateGet(this, _rejectionDetails) !== void 0;
  }
  get rejectionDetails() {
    return __privateGet(this, _rejectionDetails);
  }
}
_rejectionDetails = new WeakMap();

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class HttpPostIngressEventPublisher {
  constructor(logger, ingresses) {
    this.logger = logger;
    this.ingresses = ingresses;
    __publicField(this, "eventBroker");
  }
  static fromConfig(env) {
    var _a, _b;
    const topics = (_a = env.config.getOptionalStringArray("events.http.topics")) != null ? _a : [];
    const ingresses = (_b = env.ingresses) != null ? _b : {};
    topics.forEach((topic) => {
      if (!ingresses[topic]) {
        ingresses[topic] = {};
      }
    });
    return new HttpPostIngressEventPublisher(env.logger, ingresses);
  }
  bind(router) {
    router.use("/http", this.createRouter(this.ingresses));
  }
  async setEventBroker(eventBroker) {
    this.eventBroker = eventBroker;
  }
  createRouter(ingresses) {
    const router = Router__default["default"]();
    router.use(express__default["default"].json());
    Object.keys(ingresses).forEach(
      (topic) => this.addRouteForTopic(router, topic, ingresses[topic].validator)
    );
    router.use(backendCommon.errorHandler());
    return router;
  }
  addRouteForTopic(router, topic, validator) {
    const path = `/${topic}`;
    router.post(path, async (request, response) => {
      const requestDetails = {
        body: request.body,
        headers: request.headers
      };
      const context = new RequestValidationContextImpl();
      await (validator == null ? void 0 : validator(requestDetails, context));
      if (context.wasRejected()) {
        response.status(context.rejectionDetails.status).json(context.rejectionDetails.payload);
        return;
      }
      const eventPayload = request.body;
      await this.eventBroker.publish({
        topic,
        eventPayload,
        metadata: request.headers
      });
      response.status(202).json({ status: "accepted" });
    });
    this.logger.info(`Registered /api/events/http${path} to receive events`);
  }
}

exports.DefaultEventBroker = DefaultEventBroker;
exports.HttpPostIngressEventPublisher = HttpPostIngressEventPublisher;
//# sourceMappingURL=HttpPostIngressEventPublisher-6e928c08.cjs.js.map
