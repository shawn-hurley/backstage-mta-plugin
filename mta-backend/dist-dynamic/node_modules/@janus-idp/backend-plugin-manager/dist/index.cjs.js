'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs$1 = require('fs/promises');
var fs = require('fs');
var chokidar = require('chokidar');
var path = require('path');
var url = require('url');
var debounce = require('lodash/debounce');
var cliNode = require('@backstage/cli-node');
var backendPluginApi = require('@backstage/backend-plugin-api');
var cliCommon = require('@backstage/cli-common');
var alpha = require('@backstage/backend-plugin-api/alpha');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespace(fs$1);
var fs__namespace$1 = /*#__PURE__*/_interopNamespace(fs);
var chokidar__namespace = /*#__PURE__*/_interopNamespace(chokidar);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var url__namespace = /*#__PURE__*/_interopNamespace(url);
var debounce__default = /*#__PURE__*/_interopDefaultLegacy(debounce);

function isBackendDynamicPluginInstaller(obj) {
  return obj !== void 0 && "kind" in obj && (obj.kind === "new" || obj.kind === "legacy");
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _config;
class PluginScanner {
  constructor(config, logger, backstageRoot, preferAlpha = false) {
    __publicField$1(this, "logger");
    __publicField$1(this, "backstageRoot");
    __privateAdd(this, _config, void 0);
    __publicField$1(this, "_rootDirectory");
    __publicField$1(this, "preferAlpha");
    __publicField$1(this, "configUnsubscribe");
    __publicField$1(this, "rootDirectoryWatcher");
    __publicField$1(this, "subscribers", []);
    this.backstageRoot = backstageRoot;
    this.logger = logger;
    this.preferAlpha = preferAlpha;
    __privateSet(this, _config, config);
    this.applyConfig();
  }
  subscribeToRootDirectoryChange(subscriber) {
    this.subscribers.push(subscriber);
  }
  get rootDirectory() {
    return this._rootDirectory;
  }
  applyConfig() {
    const dynamicPlugins = __privateGet(this, _config).getOptional("dynamicPlugins");
    if (!dynamicPlugins) {
      this.logger.info("'dynamicPlugins' config entry not found.");
      this._rootDirectory = void 0;
      return;
    }
    if (typeof dynamicPlugins !== "object") {
      this.logger.warn("'dynamicPlugins' config entry should be an object.");
      this._rootDirectory = void 0;
      return;
    }
    if (!("rootDirectory" in dynamicPlugins)) {
      this.logger.warn(
        "'dynamicPlugins' config entry does not contain the 'rootDirectory' field."
      );
      this._rootDirectory = void 0;
      return;
    }
    if (typeof dynamicPlugins.rootDirectory !== "string") {
      this.logger.warn(
        "'dynamicPlugins.rootDirectory' config entry should be a string."
      );
      this._rootDirectory = void 0;
      return;
    }
    const dynamicPluginsRootPath = path__namespace.isAbsolute(dynamicPlugins.rootDirectory) ? path__namespace.resolve(dynamicPlugins.rootDirectory) : path__namespace.resolve(this.backstageRoot, dynamicPlugins.rootDirectory);
    if (!path__namespace.dirname(dynamicPluginsRootPath).startsWith(path__namespace.resolve(this.backstageRoot))) {
      const nodePath = process.env.NODE_PATH;
      const backstageNodeModules = path__namespace.resolve(
        this.backstageRoot,
        "node_modules"
      );
      if (!nodePath || !nodePath.split(path__namespace.delimiter).includes(backstageNodeModules)) {
        throw new Error(
          `Dynamic plugins under '${dynamicPluginsRootPath}' cannot access backstage modules in '${backstageNodeModules}'.
Please add '${backstageNodeModules}' to the 'NODE_PATH' when running the backstage backend.`
        );
      }
    }
    if (!fs.lstatSync(dynamicPluginsRootPath).isDirectory()) {
      throw new Error("Not a directory");
    }
    this._rootDirectory = dynamicPluginsRootPath;
  }
  async scanRoot() {
    var _a;
    if (!this._rootDirectory) {
      return [];
    }
    const dynamicPluginsLocation = this._rootDirectory;
    const scannedPlugins = [];
    for (const dirEnt of await fs__namespace.readdir(dynamicPluginsLocation, {
      withFileTypes: true
    })) {
      const pluginDir = dirEnt;
      const pluginHome = path__namespace.normalize(
        path__namespace.resolve(dynamicPluginsLocation, pluginDir.name)
      );
      if (dirEnt.isSymbolicLink()) {
        if (!(await fs__namespace.lstat(await fs__namespace.readlink(pluginHome))).isDirectory()) {
          this.logger.info(
            `skipping '${pluginHome}' since it is not a directory`
          );
          continue;
        }
      } else if (!dirEnt.isDirectory()) {
        this.logger.info(
          `skipping '${pluginHome}' since it is not a directory`
        );
        continue;
      }
      let scannedPlugin;
      let platform;
      try {
        scannedPlugin = await this.scanDir(pluginHome);
        if (!scannedPlugin.manifest.main) {
          throw new Error("field 'main' not found in 'package.json'");
        }
        if ((_a = scannedPlugin.manifest.backstage) == null ? void 0 : _a.role) {
          platform = cliNode.PackageRoles.getRoleInfo(
            scannedPlugin.manifest.backstage.role
          ).platform;
        } else {
          throw new Error("field 'backstage.role' not found in 'package.json'");
        }
      } catch (e) {
        this.logger.error(
          `failed to load dynamic plugin manifest from '${pluginHome}'`,
          e
        );
        continue;
      }
      if (platform === "node") {
        if (this.preferAlpha) {
          const pluginHomeAlpha = path__namespace.resolve(pluginHome, "alpha");
          if ((await fs__namespace.lstat(pluginHomeAlpha)).isDirectory()) {
            const backstage = scannedPlugin.manifest.backstage;
            try {
              scannedPlugin = await this.scanDir(pluginHomeAlpha);
            } catch (e) {
              this.logger.error(
                `failed to load dynamic plugin manifest from '${pluginHomeAlpha}'`,
                e
              );
              continue;
            }
            scannedPlugin.manifest.backstage = backstage;
          } else {
            this.logger.warn(
              `skipping '${pluginHomeAlpha}' since it is not a directory`
            );
          }
        }
      }
      scannedPlugins.push(scannedPlugin);
    }
    return scannedPlugins;
  }
  async scanDir(pluginHome) {
    const manifestFile = path__namespace.resolve(pluginHome, "package.json");
    const content = await fs__namespace.readFile(manifestFile);
    const manifest = JSON.parse(content.toString());
    return {
      location: url__namespace.pathToFileURL(pluginHome),
      manifest
    };
  }
  async trackChanges() {
    const setupRootDirectoryWatcher = async () => {
      return new Promise((resolve, reject) => {
        if (!this._rootDirectory) {
          resolve();
          return;
        }
        const callSubscribers = debounce__default["default"](() => {
          this.subscribers.forEach((s) => s());
        }, 500);
        let ready = false;
        this.rootDirectoryWatcher = chokidar__namespace.watch(this._rootDirectory, {
          ignoreInitial: true,
          followSymlinks: true
        }).on(
          "all",
          (event, eventPath, _) => {
            if (["addDir", "unlinkDir"].includes(event) && path__namespace.dirname(eventPath) === this._rootDirectory || ["add", "unlink", "change"].includes(event) && path__namespace.dirname(path__namespace.dirname(eventPath)) === this._rootDirectory && path__namespace.basename(eventPath) === "package.json") {
              this.logger.info(
                `rootDirectory changed (${event} - ${eventPath}): scanning plugins again`
              );
              callSubscribers();
            } else {
              this.logger.debug(
                `rootDirectory changed (${event} - ${eventPath}): no need to scan plugins again`
              );
            }
          }
        ).on("error", (error) => {
          this.logger.error(
            `error while watching '${this.rootDirectory}'`,
            error
          );
          if (!ready) {
            reject(error);
          }
        }).on("ready", () => {
          ready = true;
          resolve();
        });
      });
    };
    await setupRootDirectoryWatcher();
    if (__privateGet(this, _config).subscribe) {
      const { unsubscribe } = __privateGet(this, _config).subscribe(
        async () => {
          const oldRootDirectory = this._rootDirectory;
          try {
            this.applyConfig();
          } catch (e) {
            this.logger.error(
              "failed to apply new config for dynamic plugins",
              e
            );
          }
          if (oldRootDirectory !== this._rootDirectory) {
            this.logger.info(
              `rootDirectory changed in Config from '${oldRootDirectory}' to '${this._rootDirectory}'`
            );
            this.subscribers.forEach((s) => s());
            if (this.rootDirectoryWatcher) {
              await this.rootDirectoryWatcher.close();
            }
            await setupRootDirectoryWatcher();
          }
        }
      );
      this.configUnsubscribe = unsubscribe;
    }
  }
  async untrackChanges() {
    if (this.rootDirectoryWatcher) {
      this.rootDirectoryWatcher.close();
    }
    if (this.configUnsubscribe) {
      this.configUnsubscribe();
    }
  }
  destructor() {
    this.untrackChanges();
  }
}
_config = new WeakMap();

class CommonJSModuleLoader {
  constructor(logger) {
    this.logger = logger;
  }
  async bootstrap(backstageRoot, dynamicPluginsPaths) {
    const allowedNodeModulesPaths = [
      `${backstageRoot}/node_modules`,
      ...dynamicPluginsPaths.map((p) => path__default["default"].resolve(p, "node_modules"))
    ];
    const Module = require("module");
    const oldNodeModulePaths = Module._nodeModulePaths;
    Module._nodeModulePaths = (from) => {
      const result = oldNodeModulePaths(from);
      if (!dynamicPluginsPaths.some((p) => from.startsWith(p))) {
        return result;
      }
      const filtered = result.filter((p) => allowedNodeModulesPaths.includes(p));
      this.logger.debug(
        `Overriding node_modules search path for dynamic plugin ${from} to: ${filtered}`
      );
      return filtered;
    };
  }
  async load(packagePath) {
    return await (function (t) { return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(t)); }); })(
      /* webpackIgnore: true */
      packagePath
    );
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class PluginManager {
  constructor(logger, packages, moduleLoader) {
    this.logger = logger;
    this.packages = packages;
    this.moduleLoader = moduleLoader;
    __publicField(this, "plugins");
    __publicField(this, "_availablePackages");
    this.plugins = [];
    this._availablePackages = packages;
  }
  static async fromConfig(config, logger, preferAlpha = false, mooduleLoader = new CommonJSModuleLoader(logger)) {
    const backstageRoot = cliCommon.findPaths(__dirname).targetRoot;
    const scanner = new PluginScanner(
      config,
      logger,
      backstageRoot,
      preferAlpha
    );
    const scannedPlugins = await scanner.scanRoot();
    scanner.trackChanges();
    const manager = new PluginManager(logger, scannedPlugins, mooduleLoader);
    const dynamicPluginsPaths = scannedPlugins.map(
      (p) => fs__namespace$1.realpathSync(
        path__default["default"].dirname(
          path__default["default"].dirname(
            path__default["default"].resolve(url__namespace.fileURLToPath(p.location), p.manifest.main)
          )
        )
      )
    );
    mooduleLoader.bootstrap(backstageRoot, dynamicPluginsPaths);
    scanner.subscribeToRootDirectoryChange(async () => {
      manager._availablePackages = await scanner.scanRoot();
    });
    manager.plugins.push(...await manager.loadPlugins());
    return manager;
  }
  get availablePackages() {
    return this._availablePackages;
  }
  addBackendPlugin(plugin) {
    this.plugins.push(plugin);
  }
  async loadPlugins() {
    const loadedPlugins = [];
    for (const scannedPlugin of this.packages) {
      const platform = cliNode.PackageRoles.getRoleInfo(
        scannedPlugin.manifest.backstage.role
      ).platform;
      if (platform === "node" && scannedPlugin.manifest.backstage.role.includes("-plugin")) {
        const plugin = await this.loadBackendPlugin(scannedPlugin);
        if (plugin !== void 0) {
          loadedPlugins.push(plugin);
        }
      } else {
        loadedPlugins.push({
          name: scannedPlugin.manifest.name,
          version: scannedPlugin.manifest.version,
          role: scannedPlugin.manifest.backstage.role,
          platform: "web"
          // TODO(davidfestal): add required front-end plugin information here.
        });
      }
    }
    return loadedPlugins;
  }
  async loadBackendPlugin(plugin) {
    const packagePath = url__namespace.fileURLToPath(
      `${plugin.location}/${plugin.manifest.main}`
    );
    try {
      const { dynamicPluginInstaller } = await this.moduleLoader.load(
        packagePath
      );
      if (!isBackendDynamicPluginInstaller(dynamicPluginInstaller)) {
        this.logger.error(
          `dynamic backend plugin '${plugin.manifest.name}' could not be loaded from '${plugin.location}': the module should export a 'const dynamicPluginInstaller: BackendDynamicPluginInstaller' field.`
        );
        return void 0;
      }
      this.logger.info(
        `loaded dynamic backend plugin '${plugin.manifest.name}' from '${plugin.location}'`
      );
      return {
        name: plugin.manifest.name,
        version: plugin.manifest.version,
        platform: "node",
        role: plugin.manifest.backstage.role,
        installer: dynamicPluginInstaller
      };
    } catch (error) {
      this.logger.error(
        `an error occured while loading dynamic backend plugin '${plugin.manifest.name}' from '${plugin.location}'`,
        error
      );
      return void 0;
    }
  }
  backendPlugins() {
    return this.plugins.filter(
      (p) => p.platform === "node"
    );
  }
}
const dynamicPluginsServiceRef = backendPluginApi.createServiceRef(
  {
    id: "core.dynamicplugins",
    scope: "root"
  }
);
const dynamicPluginsServiceFactory = backendPluginApi.createServiceFactory(
  (options) => ({
    service: dynamicPluginsServiceRef,
    deps: {
      config: backendPluginApi.coreServices.rootConfig,
      logger: backendPluginApi.coreServices.rootLogger
    },
    async factory({ config, logger }) {
      if (options == null ? void 0 : options.moduleLoader) {
        return await PluginManager.fromConfig(
          config,
          logger,
          true,
          options.moduleLoader(logger)
        );
      }
      return await PluginManager.fromConfig(config, logger, true);
    }
  })
);
class DynamicPluginsEnabledFeatureDiscoveryService {
  constructor(dynamicPlugins, featureDiscoveryService) {
    this.dynamicPlugins = dynamicPlugins;
    this.featureDiscoveryService = featureDiscoveryService;
  }
  async getBackendFeatures() {
    var _a, _b, _c;
    const staticFeatures = (_c = (_b = await ((_a = this.featureDiscoveryService) == null ? void 0 : _a.getBackendFeatures())) == null ? void 0 : _b.features) != null ? _c : [];
    return {
      features: [
        ...this.dynamicPlugins.backendPlugins().flatMap((plugin) => {
          if (plugin.installer.kind === "new") {
            const installed = plugin.installer.install();
            if (Array.isArray(installed)) {
              return installed;
            }
            return [installed];
          }
          return [];
        }),
        ...staticFeatures
      ]
    };
  }
}
const dynamicPluginsFeatureDiscoveryServiceFactory = backendPluginApi.createServiceFactory({
  service: alpha.featureDiscoveryServiceRef,
  deps: {
    config: backendPluginApi.coreServices.rootConfig,
    dynamicPlugins: dynamicPluginsServiceRef
  },
  factory({ dynamicPlugins }) {
    return new DynamicPluginsEnabledFeatureDiscoveryService(dynamicPlugins);
  }
});

exports.PluginManager = PluginManager;
exports.dynamicPluginsFeatureDiscoveryServiceFactory = dynamicPluginsFeatureDiscoveryServiceFactory;
exports.dynamicPluginsServiceFactory = dynamicPluginsServiceFactory;
exports.dynamicPluginsServiceRef = dynamicPluginsServiceRef;
exports.isBackendDynamicPluginInstaller = isBackendDynamicPluginInstaller;
//# sourceMappingURL=index.cjs.js.map
