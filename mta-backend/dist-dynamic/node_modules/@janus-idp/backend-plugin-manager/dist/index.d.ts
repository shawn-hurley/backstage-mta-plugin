import { BackstagePackageJson, PackageRole, PackagePlatform } from '@backstage/cli-node';
import { Logger } from 'winston';
import { Config } from '@backstage/config';
import { PluginCacheManager, PluginDatabaseManager, UrlReader, PluginEndpointDiscovery, TokenManager } from '@backstage/backend-common';
import { Router } from 'express';
import { PluginTaskScheduler, TaskRunner } from '@backstage/backend-tasks';
import { IdentityApi } from '@backstage/plugin-auth-node';
import { PermissionEvaluator } from '@backstage/plugin-permission-common';
import { EventBroker, HttpPostIngressOptions } from '@backstage/plugin-events-node';
import * as _backstage_backend_plugin_api from '@backstage/backend-plugin-api';
import { BackendFeature, LoggerService } from '@backstage/backend-plugin-api';
import { CatalogBuilder } from '@backstage/plugin-catalog-backend';
import { TemplateAction } from '@backstage/plugin-scaffolder-node';
import { IndexBuilder } from '@backstage/plugin-search-backend-node';
import { EventsBackend } from '@backstage/plugin-events-backend';
import { PermissionPolicy } from '@backstage/plugin-permission-node';
import { FeatureDiscoveryService } from '@backstage/backend-plugin-api/alpha';

/**
 * @public
 */
interface ModuleLoader {
    bootstrap(backstageRoot: string, dynamicPluginPaths: string[]): Promise<void>;
    load(id: string): Promise<any>;
}

/**
 * @public
 */
interface ScannedPluginPackage {
    location: URL;
    manifest: ScannedPluginManifest;
}
/**
 * @public
 */
type ScannedPluginManifest = BackstagePackageJson & Required<Pick<BackstagePackageJson, 'main'>> & Required<Pick<BackstagePackageJson, 'backstage'>> & {
    backstage: Required<BackstagePackageJson['backstage']>;
};

/**
 * @public
 *
 * @deprecated
 *
 * Support for the legacy backend system will be removed in the future.
 *
 * When adding a legacy plugin installer entrypoint in your plugin,
 * you should always take the opportunity to also implement support
 * for the new backend system if not already done.
 *
 */
type LegacyPluginEnvironment = {
    logger: Logger;
    cache: PluginCacheManager;
    database: PluginDatabaseManager;
    config: Config;
    reader: UrlReader;
    discovery: PluginEndpointDiscovery;
    tokenManager: TokenManager;
    permissions: PermissionEvaluator;
    scheduler: PluginTaskScheduler;
    identity: IdentityApi;
    eventBroker: EventBroker;
    pluginProvider: BackendPluginProvider;
};
/**
 * @public
 */
interface BackendPluginProvider {
    backendPlugins(): BackendDynamicPlugin[];
}
/**
 * @public
 */
interface BaseDynamicPlugin {
    name: string;
    version: string;
    role: PackageRole;
    platform: PackagePlatform;
}
/**
 * @public
 */
type DynamicPlugin = FrontendDynamicPlugin | BackendDynamicPlugin;
/**
 * @public
 */
interface FrontendDynamicPlugin extends BaseDynamicPlugin {
    platform: 'web';
}
/**
 * @public
 */
interface BackendDynamicPlugin extends BaseDynamicPlugin {
    platform: 'node';
    installer: BackendDynamicPluginInstaller;
}
/**
 * @public
 */
type BackendDynamicPluginInstaller = LegacyBackendPluginInstaller | NewBackendPluginInstaller;
/**
 * @public
 */
interface NewBackendPluginInstaller {
    kind: 'new';
    install(): BackendFeature | BackendFeature[];
}
/**
 * @public
 * @deprecated
 *
 * Support for the legacy backend system will be removed in the future.
 *
 * When adding a legacy plugin installer entrypoint in your plugin,
 * you should always take the opportunity to also implement support
 * for the new backend system if not already done.
 *
 */
interface LegacyBackendPluginInstaller {
    kind: 'legacy';
    router?: {
        pluginID: string;
        createPlugin(env: LegacyPluginEnvironment): Promise<Router>;
    };
    catalog?(builder: CatalogBuilder, env: LegacyPluginEnvironment): void;
    scaffolder?(env: LegacyPluginEnvironment): TemplateAction<any>[];
    search?(indexBuilder: IndexBuilder, schedule: TaskRunner, env: LegacyPluginEnvironment): void;
    events?(eventsBackend: EventsBackend, env: LegacyPluginEnvironment): HttpPostIngressOptions[];
    permissions?: {
        policy?: PermissionPolicy;
    };
}
/**
 * @public
 */
declare function isBackendDynamicPluginInstaller(obj: any): obj is BackendDynamicPluginInstaller;

/**
 * @public
 */
declare class PluginManager implements BackendPluginProvider {
    private readonly logger;
    private packages;
    private readonly moduleLoader;
    static fromConfig(config: Config, logger: LoggerService, preferAlpha?: boolean, mooduleLoader?: ModuleLoader): Promise<PluginManager>;
    readonly plugins: DynamicPlugin[];
    private _availablePackages;
    private constructor();
    get availablePackages(): ScannedPluginPackage[];
    addBackendPlugin(plugin: BackendDynamicPlugin): void;
    private loadPlugins;
    private loadBackendPlugin;
    backendPlugins(): BackendDynamicPlugin[];
}
/**
 * @public
 */
declare const dynamicPluginsServiceRef: _backstage_backend_plugin_api.ServiceRef<BackendPluginProvider, "root">;
/**
 * @public
 */
interface DynamicPluginsFactoryOptions {
    moduleLoader?(logger: LoggerService): ModuleLoader;
}
/**
 * @public
 */
declare const dynamicPluginsServiceFactory: (options?: DynamicPluginsFactoryOptions | undefined) => _backstage_backend_plugin_api.ServiceFactory<BackendPluginProvider, "root">;
/**
 * @public
 */
declare const dynamicPluginsFeatureDiscoveryServiceFactory: () => _backstage_backend_plugin_api.ServiceFactory<FeatureDiscoveryService, "root">;

export { BackendDynamicPlugin, BackendDynamicPluginInstaller, BackendPluginProvider, BaseDynamicPlugin, DynamicPlugin, DynamicPluginsFactoryOptions, FrontendDynamicPlugin, LegacyBackendPluginInstaller, LegacyPluginEnvironment, ModuleLoader, NewBackendPluginInstaller, PluginManager, ScannedPluginManifest, ScannedPluginPackage, dynamicPluginsFeatureDiscoveryServiceFactory, dynamicPluginsServiceFactory, dynamicPluginsServiceRef, isBackendDynamicPluginInstaller };
